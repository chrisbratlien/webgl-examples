<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="scream.css">
</head>

<body>

  <div class="slider-wrap flex-column">
    Texture Image
    <div class="img-canvas-pair">
      <img class="img-texture" src="diag4.png" alt="Texture" />
      <canvas class="canvas-texture">
        Your browser does not support the HTML5 canvas tag.
      </canvas>  
    </div>
    Texture File
    <input class="texture-file-input" type="file" />  
  </div>

  <div class="slider-wrap flex-column">
    <label>Scream Image</label>
    <div class="img-canvas-pair">
      <img id="scream" class="scream-jpg" src="img_the_scream.jpg" alt="The Scream">
      <canvas id="myCanvas" class="canvas-scream">
      Your browser does not support the HTML5 canvas tag.
      </canvas>    
    </div>
  </div>

  <div class="flex-column">
    Guest-supplied Image
    <div class="img-canvas-pair">
      <img class="lindt-jpg" src="lindt.jpg" alt="Chocolate">
      <canvas class="canvas-chocolate">
      Your browser does not support the HTML5 canvas tag.
      </canvas>
    </div>
    <label>Guest File</label>
    <input class="guest-file-input" type="file" />
    <select class="dd-transformer">
      <option> (choose) </option>
    </select>  
  </div>



  <script type="module">
    //import scalar, {lerp} from './scalar.js';
  import scalar, {lerp, remap, invlerp} from './scalar.js';
  window.lerp = lerp;
  window.invlerp = invlerp;
  window.remap = remap;
  window.scalar = scalar;
  //window.scalar = scalar;
</script>

  <script>
    function toXY(i, w, h) {
      let x = i % w;
      let y = Math.floor(i / w);
      return [x, y];
    }


    function chainOfTransformers(transformers) {
      //return a custom built transformer function that, when called with the same arguments as 
      // a single transformer function expects, will apply the array of transformers
      // in sequence to those arguments
      return function (...aBunchOfArgs) {
        let result = transformers.reduce(function (accum, currentTransform) {
          let [r, g, b, a] = currentTransform(...accum);
          let [x, y, uniform, oR, oG, oB, oA] = accum;

          //but now we need to pass the updated r,g,b,a 
          //along with the complete bunch of args
          return [x, y, uniform, r, g, b, a]; //new accum with updatd r,g,b,a

        }, aBunchOfArgs);

        let [x, y, uniform, nR, nG, nB, nA] = result;
        return [nR, nG, nB, nA];
      }

    }


    let transformers = [{
        name: 'identity',
        fn: function (x, y, uniform, r, g, b, a) {
          return [r, g, b, a];
        },
        sliderLabels: []
      },
      {
        name: 'follow X',
        fn: function (x, y, uniform, r, g, b, a) {
          return [x, x, x, a];
        },
      },
      {
        name: 'followY',
        fn: (x, y, uniform, r, g, b, a) => {
          return [y, y, y, a];
        },
      },
      {
        name: 'goob: sin of tx*pi',
        fn: (x, y, uniform, r, g, b, a) => {
          let v = Math.sin(x * Math.PI);
          return [v, v, v, a];
        }
      },
      {
        name: 'goobpic: sin of tx*pi*slider applied to rgb, where slider goes to 100',
        fn: (x, y, uniform, r, g, b, a) => {
          let s = +uniform.sliders[0].value * 100;
          let v = Math.sin(s * x * Math.PI);
          r *= v;
          g *= v;
          b *= v;

          return [r, g, b, a];
        }
      },
      {
        name: 'goobpic3',
        fn: (x, y, uniform, r, g, b, a) => {
          let sr = +uniform.sliders[0].value * 100;
          let sg = +uniform.sliders[1].value * 100;
          let sb = +uniform.sliders[2].value * 100;
          let vr = Math.sin(sr * x * Math.PI);
          let vg = Math.sin(sg * x * Math.PI);
          let vb = Math.sin(sb * x * Math.PI);
          r *= vr;
          g *= vg;
          b *= vb;

          return [r, g, b, a];
        }
      },
      {
        name: 'goobpic4',
        fn: (x, y, uniform, r, g, b, a) => {

          let sr = +uniform.sliders[0].value;
          let sg = +uniform.sliders[1].value;
          let sb = +uniform.sliders[2].value;
          let sa = +uniform.sliders[3].value;

          r *= sr * 2;
          g *= sg * 2;
          b *= sb * 2;
          a *= sa * 2;

          return [r, g, b, a];
        }
      },
      {
        name: 'goobpic5 slider: lerps r,g,b(0..1) towards 1',
        fn: (x, y, uniform, r, g, b, a) => {

          let sr = +uniform.sliders[0].value;
          let sg = +uniform.sliders[1].value;
          let sb = +uniform.sliders[2].value;
          let sa = +uniform.sliders[3].value;

          //console.log(r,'r!','g',g,'b',b);
          r = lerp(r, 1, sr);
          g = lerp(g, 1, sg);
          b = lerp(b, 1, sb);
          ///a = lerp(a,1,sa);

          return [r, g, b, a];
        }
      },
      {
        name: 'goobpic6 slider: lerp/extrapolate +/- diff towards/away white',
        fn: (x, y, uniform, r, g, b, a) => {

          let sr = +uniform.sliders[0].value;
          let sg = +uniform.sliders[1].value;
          let sb = +uniform.sliders[2].value;
          let sa = +uniform.sliders[3].value;

          sr = remap(0, 1, -1, 1, sr);
          sg = remap(0, 1, -1, 1, sg);
          sb = remap(0, 1, -1, 1, sb);

          r = lerp(r, 1, sr);
          g = lerp(g, 1, sg);
          b = lerp(b, 1, sb);

          return [r, g, b, a];
        }
      },
      {
        name: 'tXY',
        fn: (x, y, uniform, r, g, b, a) => {
          let v = (x + y) / 2;
          return [v, v, v, a];
        },
      },
      {
        name: 'redFadeOutWithY',
        fn: (x, y, uniform, r, g, b, a) => {
          r *= 1 - y;
          return [r, g, b, a];
        },
      },
      {
        name: 'redFadeInWithY',
        fn: (x, y, uniform, r, g, b, a) => {
          r *= y;
          return [r, g, b, a];
        },
      },
      {
        name: 'dunno',
        fn: (x, y, uniform, r, g, b, a) => {
          //r *= t_y;
          let t2 = Math.sqrt(x ** 2 + y ** 2)
          let t3 = (t2 ** 2);
          r *= t3;
          g *= t3;
          b *= t3;
          return [r, g, b, a];
        },
      },
      {
        name: 'blushy',
        fn: (x, y, uniform, r, g, b, a) => {
          r *= Math.sin(x * Math.PI) * Math.cos(y * Math.PI);
          //g = r;
          b = r;
          return [r, g, b, a];
        },
      },
      {
        name: 'remap input sliders',
        fn: (x, y, uniform, r, g, b, a) => {
          let start = +uniform.sliders[0].value;
          let end = +uniform.sliders[1].value;
          r = remap(start, end, 0, 1, r);
          g = remap(start, end, 0, 1, g);
          b = remap(start, end, 0, 1, b);
          return [r, g, b, a];
        },
      },
      {
        name: 'transformColor: a bunch of crazy',
        fn: (x, y, uniform, r, g, b, a, textureR) => {
          r = 3 * r * (1 - y) * Math.sin(2 * x * Math.PI);
          g = 3 * g * (1 - x) * Math.sin(2 * y * Math.PI);
          b = 3 * b * (1 - x * y) * Math.sin(2 * x * y * Math.PI);

          return [r, g, b, a];
        }
      },
      {
        name: 'transformColor: a bunch of crazy, with texture',
        fn: (x, y, uniform, r, g, b, a, tr, tg, tb, ta) => {
          r = 3 * r * (1 - y) * Math.sin(2 * x * Math.PI);
          g = 3 * g * (1 - x) * Math.sin(2 * y * Math.PI);
          b = 3 * b * (1 - x * y) * Math.sin(2 * x * y * Math.PI);

          r *= tr;
          g *= tg;
          b *= tb;
          a *= ta;
          return [r, g, b, a];
        }
      },
      {
        name: 'texture: texture only',
        fn: (x, y, uniform, r, g, b, a, tr, tg, tb, ta) => {

          r = tr;
          g = tg;
          b = tb;
          a = ta;
          return [r, g, b, a];
        }
      },
      {
        name: 'texture: mask experiment',
        fn: (x, y, uniform, r, g, b, a, tr, tg, tb, ta) => {

          r *= tr;
          g *= tg;
          b *= tb;
          a *= ta;
          return [r, g, b, a];
        }
      },
      {
        name: 'texture mask: 1 - texture red channel',
        fn: (x, y, uniform, r, g, b, a, tr, tg, tb, ta) => {

          let v = 1 - tr;
          r *= v;
          g *= v;
          b *= v;
          a *= v;
          return [r, g, b, a];
        }
      }

    ];

    transformers.push({
      'name': 'combined transformColor with remap Input sliders',
      fn: chainOfTransformers([
        transformers.find(o => o.name.match(/transformColor/)).fn,
        transformers.find(o => o.name.match(/remap input sliders/)).fn,
      ])
    })

    transformers.push({
      'name': 'combined: texture mask exper -> transformColor',
      fn: chainOfTransformers([
        transformers.find(o => o.name.match(/texture: mask exper/)).fn,
        transformers.find(o => o.name.match(/transformColor/)).fn,
        transformers.find(o => o.name.match(/remap input sliders/)).fn,
      ])
    })





    function process(c, img, transformer) {
      var ctx = c.getContext("2d");
      var textureContext = textureCanvas.getContext('2d');
      textureCanvas.width = textureImg.width;
      textureCanvas.height = textureImg.height;
      textureContext.drawImage(textureImg, 0, 0);
      var textureData = textureContext.getImageData(0, 0, textureCanvas.width, textureCanvas.height);

      console.log('textureData', textureData);

      c.width = img.width;
      c.height = img.height;
      ctx.drawImage(img, 0, 0);
      var imgData = ctx.getImageData(0, 0, c.width, c.height);
      //console.log(c.width,c.height);
      ///console.log('imgData',imgData);

      var i, pixelIdx = 0;
      for (i = 0; i < imgData.data.length; i += 4) {
        let pixelIdx = Math.floor(i / 4);
        let [x, y] = toXY(pixelIdx, c.width, c.height);
        //let t = lerp()
        //scalar.remap(0,277,0,1,276)
        let x01 = invlerp(0, c.width, x);
        let y01 = invlerp(0, c.height, y);
        let x255 = remap(0, c.width, 0, 255, x);
        let y255 = remap(0, c.height, 0, 255, y);


        var [r255, g255, b255, a255] = [
          imgData.data[i + 0],
          imgData.data[i + 1],
          imgData.data[i + 2],
          imgData.data[i + 3],
        ];

        //var texturePixelIdx = (pixelIdx % textureCanvas.width);

        var textureY = y % textureCanvas.height;
        var texturePixelIdx = textureY * textureCanvas.width +  (pixelIdx % c.width) % textureCanvas.width;
      
        var textureI = texturePixelIdx * 4;
        var textureR255 = textureData.data[textureI + 0];
        var textureG255 = textureData.data[textureI + 1];
        var textureB255 = textureData.data[textureI + 2];
        var textureA255 = textureData.data[textureI + 3];

       false && console.log(
          'i', i,
          'x', x,
          'y', y,
          'pixelIdx', pixelIdx,
          'y', y,
          'textureY', textureY,
          'texturePixelIdx', texturePixelIdx,
          'textureI', textureI,
          'tr255', textureR255,
          'tg255', textureG255,
          'tb', textureB255,
          'ta', textureA255);

        if (false && pixelIdx > 1600) {
          break;
        }


        //console.log('i',i,'pixelIdx',pixelIdx,'x',x,'y',y,'t_x',t_x,'v_x',v_x);

        let [r, g, b, a] = transformer(
          x01, //x remapped from 0 to 1
          y01, //y remapped from 0 to 1
          {
            ...uniform,
            width: c.width,
            height: c.height
          },
          r255 / 255, //r from 0 to 1
          g255 / 255, //g from 0 to 1
          b255 / 255, //b from 0 to 1
          a255 / 255, //a from 0 to 1
          textureR255 / 255, //texture R from 0 to 1
          textureG255 / 255, //texture G from 0 to 1
          textureB255 / 255, //texture B from 0 to 1
          textureA255 / 255, //texture A from 0 to 1
        );

        imgData.data[i + 0] = r * 255;
        imgData.data[i + 1] = g * 255;
        imgData.data[i + 2] = b * 255;
        imgData.data[i + 3] = a * 255;
        pixelIdx += 1;
      }
      ctx.putImageData(imgData, 0, 0);
    }

    var c = document.getElementById("myCanvas");
    var img = document.getElementById("scream");

    var textureCanvas = document.querySelector('.canvas-texture');
    var textureImg = document.querySelector('.img-texture');
    var textureFileInput = document.querySelector('.texture-file-input');
    ////textureImg.src='diag16.png';



    var c2 = document.querySelector('.canvas-chocolate');
    var img2 = document.querySelector('.lindt-jpg');

    var sel = document.querySelector('.dd-transformer');
    var sliderWrap = document.querySelector('.slider-wrap');
    var guestFileInput = document.querySelector('.guest-file-input');

    var procrastinator = false;

    var uniform = {
      sliders: [],
      sliderLabels: []
    };

    transformers.forEach(function (tra) {
      var opt = document.createElement('option');
      opt.value = tra.name;
      opt.innerText = tra.name;
      sel.appendChild(opt)
    });

    let selectedFN = transformers[0].fn

    function getFN() {
      if (sel.selectedIndex == 0) {
        return false;
      }
      let tra = transformers[sel.selectedIndex - 1]; //nothing is in the 0 index
      return tra.fn;
    }

    sel.addEventListener('change', function () {
      //console.log('selInd',sel.selectedIndex);
      selectedFN = getFN();
      process(c, img, selectedFN)
      process(c2, img2, selectedFN);
    });


    setTimeout(function () {
      //sometimtes this was causing process to run before the js modules have 
      //finished loading... so the setTimeout is an ugly temporary fix
      img2.addEventListener('load', function () {
        console.log('LOAD!!!');
        process(c2, img2, selectedFN);
      });



    }, 2000);



    function setupFileInput(input,onload) {
      input.addEventListener('change', function (e) {
        console.log(e.target.files);
        var file = e.target.files[0];
        var reader = new FileReader();
        reader.onload = onload;
        reader.readAsDataURL(file);
      });
    }

    setupFileInput(guestFileInput,function(e) {
      img2.src = e.target.result;
    });

    setupFileInput(textureFileInput,function(e) {
      textureImg.src = e.target.result;
    });


    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(function (n) {
      let sl = document.createElement('input');
      sl.step = 0.01;
      sl.min = 0;
      sl.max = 1;
      sl.value = 0;
      let label = document.createElement('label');
      label.innerText = '0 to 1'
      sl.type = 'range';
      sliderWrap.appendChild(sl);
      sliderWrap.appendChild(label);
      sl.addEventListener('change', function (e) {
        //console.log(e.target.value,sl.value)
        clearTimeout(procrastinator);
        procrastinator = setTimeout(function () {
          process(c, img, selectedFN)
          process(c2, img2, selectedFN);
        }, 100);
      });
      uniform.sliders.push(sl);
      uniform.sliderLabels.push(label);
    });
  </script>

</body>

</html>