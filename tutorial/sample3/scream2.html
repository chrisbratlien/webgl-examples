<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="scream.css">
</head>
<body>

  <img id="scream" src="img_the_scream.jpg" alt="The Scream">
  <canvas id="myCanvas">
  Your browser does not support the HTML5 canvas tag.
</canvas>


  <img class="lindt-jpg" src="lindt.jpg" alt="Chocolate">
  <canvas class="canvas-chocolate">
  Your browser does not support the HTML5 canvas tag.
  </canvas>
  <input class="file-input" type="file" />
<br />
  <select class="dd-transformer">
    <option> (choose) </option>
  </select>
  <div class="slider-wrap flex-column">
  </div>
  

<script type="module">
  //import scalar, {lerp} from './scalar.js';
  import scalar, {lerp, remap, invlerp} from './scalar.js';
  window.lerp = lerp;
  window.invlerp = invlerp;
  window.remap = remap;
  window.scalar = scalar;
  //window.scalar = scalar;
</script>

<script>
function toXY(i,w,h) {
  let x = i % w;
  let y = Math.floor(i / w);
  return [x,y];
}


function chainOfTransforms(transforms) {
  return function(...aBunchOfArgs) {
    let result = transforms.reduce(function(accum,currentTransform){
        let [r,g,b,a] = currentTransform(...accum);
        let [oX,oY,oTX,oTY,oVX,oVY,oR,oG,oB,oA,...tail] = accum;
        //but now we need to pass the updated r,g,b,a 
        //along with the complete bunch of args
        return [oX,oY,oTX,oTY,oVX,oVY,r,g,b,a,...tail]; //new accum with updatd r,g,b,a

    },aBunchOfArgs);

    let [oX,oY,oTX,oTY,oVX,oVY,nR,nG,nB,nA,...tail] = result;
    return [nR,nG,nB,nA];
    ////return result; //reduction of applying all the transforms
  }

}


let transformers = [
  {
  name: 'identity',
    fn: function(x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) {
      return [r, g, b, a];
    },
    sliderLabels: []
  },
  {
    name: 'follow X',
    fn: function(x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) {
      return [v_x, v_x, v_x, a];
    },
  },
  {
    name: 'followY',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      return [v_y, v_y, v_y, a];
    },
  },
  {
    name: 'goob: sin of tx*pi',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let v = Math.sin(t_x * Math.PI) * 255;
      return [v, v, v, a];
    }
  },
  {
    name: 'goobpic: sin of tx*pi*slider applied to rgb, where slider goes to 100',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let s = + uniform.sliders[0].value * 100;
      let v = Math.sin(s * t_x * Math.PI);
      r *= v;
      g *= v;
      b *= v;

      return [r, g, b, a];
    }
  },
  {
    name: 'goobpic3',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let sr = + uniform.sliders[0].value * 100;
      let sg = + uniform.sliders[1].value * 100;
      let sb = + uniform.sliders[2].value * 100;
      let vr = Math.sin(sr * t_x * Math.PI);
      let vg = Math.sin(sg * t_x * Math.PI);
      let vb = Math.sin(sb * t_x * Math.PI);
      r *= vr;
      g *= vg;
      b *= vb;

      return [r, g, b, a];
    }
  },
  {
    name: 'goobpic4',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {

      let sr = + uniform.sliders[0].value;
      let sg = + uniform.sliders[1].value;
      let sb = + uniform.sliders[2].value;
      let sa = + uniform.sliders[3].value;

      r *= sr * 2;
      g *= sg * 2;
      b *= sb * 2;
      a *= sa * 2;

      return [r, g, b, a];
    }
  },  
  {
    name: 'goobpic5 slider: lerps r,g,b(255) towards 255',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {

      let sr = + uniform.sliders[0].value;
      let sg = + uniform.sliders[1].value;
      let sb = + uniform.sliders[2].value;
      let sa = + uniform.sliders[3].value;

      //console.log(r,'r!','g',g,'b',b);
      r = lerp(r,255,sr);
      g = lerp(g,255,sg);
      b = lerp(b,255,sb);
      ///a = lerp(a,255,sa);

      return [r, g, b, a];
    }
  },  
  {
    name: 'goobpic6 slider: lerp +/- diff towards white',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {

      let sr = + uniform.sliders[0].value;
      let sg = + uniform.sliders[1].value;
      let sb = + uniform.sliders[2].value;
      let sa = + uniform.sliders[3].value;

      /*
      sr = 2 * sr - 1;
      sg = 2 * sg - 1;
      sb = 2 * sb - 1;
      */
      sr = remap(0,1,-1,1,sr);
      sg = remap(0,1,-1,1,sg);
      sb = remap(0,1,-1,1,sb);

      r = lerp(r,255,sr);
      g = lerp(g,255,sg);
      b = lerp(b,255,sb);

      return [r, g, b, a];
    }
  },  
  {
    name: 'tXY',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let v = ((v_x * t_x) + (v_y * t_y))/2;
      return [v, v, v, a];
    },
  },
  {
    name: 'tv',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let tv = (v_x + v_y) * 0.5;
      return [tv, tv, tv, a];
    },
  },
  {
    name: 'redFadeOutWithY',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      r *= (1-t_y);
      return [r,g,b,a];
    },
  },
  {
    name: 'redFadeInWithY',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      r *= t_y;
      return [r,g,b,a];
    },
  },
  {
    name: 'dunno',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      //r *= t_y;
      let t2 = Math.sqrt(t_x**2 + t_y**2)
      let t3 = (t2**2);
      r *= t3;
      g *= t3;
      b *= t3;
      return [r,g,b,a];
    },
  },
  {
    name: 'blushy',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let tv = (v_x + v_y) * 0.5;
      //r *= t_x * t_y;
      //g *= t_x * t_y;
      r *= Math.sin(t_x * Math.PI) * Math.cos(t_y * Math.PI);
      //g = r;
      b = r;
      //r *= (1-t_y);
      //g *= (1-t_x);
      //b *= (1-t_y);// * t_y;
      //b *= t_x * t_y;
      //r = v_x;
      //g = tv;
      //g = tv;
      //b = tv;
      return [r,g,b,a];
    },
  },
  {
    name: 'remap input sliders',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let start255 = + uniform.sliders[0].value * 255;
      let end255 = + uniform.sliders[1].value * 255;
      r = remap(start255,end255,0,255,r);
      g = remap(start255,end255,0,255,g);
      b = remap(start255,end255,0,255,b);
      return [r, g, b, a];
    },
  },
  {
    name: 'remap output sliders',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let start255 = + uniform.sliders[0].value * 255;
      let end255 = + uniform.sliders[1].value * 255;
      r = remap(0,255,start255,end255,r);
      g = remap(0,255,start255,end255,g);
      b = remap(0,255,start255,end255,b);
      return [r, g, b, a];
    },
  },
  {
    name: 'remap outer in/out sliders',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let start255 = + uniform.sliders[0].value * 255;
      let end255 = + uniform.sliders[1].value * 255;
      r = remap(start255,255,0,end255,r);
      g = remap(start255,255,0,end255,g);
      b = remap(start255,255,0,end255,b);
      return [r, g, b, a];
    },
  },
  {
    name: 'remap inner in/out sliders',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let start255 = + uniform.sliders[0].value * 255;
      let end255 = + uniform.sliders[1].value * 255;
      r = remap(0,start255,end255,255,r);
      g = remap(0,start255,end255,255,g);
      b = remap(0,start255,end255,255,b);
      return [r, g, b, a];
    },
  },
  {
    name: 'transformColor',
    fn: (x,y,t_x,t_y,v_x,v_y,r,g,b,a,uniform,tr,tg,tb,ta) => {
      let tv = (v_x + v_y) * 0.5;
      r = 3 * r * (1-t_y) * Math.sin(2 * t_x * Math.PI);
      g = 3 * g * (1-t_x) * Math.sin(2 * t_y * Math.PI);
      b = 3 * b * (1-t_x * t_y) * Math.sin(2 * t_x * t_y * Math.PI);
      //g *= t_x * t_y;
      //r *= Math.sin(t_x * Math.PI) * Math.cos(t_y * Math.PI);
      //g = r;
      //g *= t_y * (1-t_x);
      // b *= t_y;
      //r *= (1-t_y);
      //g *= (1-t_x);
      //b *= (1-t_y);// * t_y;
      //b *= t_x * t_y;
      //r = v_x;
      //g = tv;
      //g = tv;
      //b = tv;
      return [r,g,b,a];
    }
  }
];

transformers.push({
  'name': 'combined tC with remap Input sliders',
  fn: chainOfTransforms([
  transformers.find(o => o.name.match(/transformColor/)).fn,
  transformers.find(o => o.name.match(/remap input sliders/)).fn,  
  ])
})



function process(c,img,transformer) {
  var ctx = c.getContext("2d");
  c.width = img.width;
  c.height = img.height;
  ctx.drawImage(img, 0, 0);
  var imgData = ctx.getImageData(0, 0, c.width, c.height);
  //console.log(c.width,c.height);
  console.log('imgData',imgData);
  
  var i,pixelIdx = 0;
  for (i = 0; i < imgData.data.length; i += 4) {
    let pixelIdx = Math.floor(i / 4);
    let [x,y] = toXY(pixelIdx, c.width, c.height);
    //let t = lerp()
    //scalar.remap(0,277,0,1,276)
    let t_x = invlerp(0,c.width,x);
    let t_y = invlerp(0,c.height,y);
    let v_x =  remap(0,c.width,0,255,x);
    let v_y =  remap(0,c.height,0,255,y);


    var [r,g,b,a] = [
      imgData.data[i+0],
      imgData.data[i+1],
      imgData.data[i+2],
      imgData.data[i+3],
    ];
    //console.log('i',i,'pixelIdx',pixelIdx,'x',x,'y',y,'t_x',t_x,'v_x',v_x);

    [r,g,b,a] = transformer(
      x,
      y,
      t_x, //x remapped from 0 to 1
      t_y, //y remapped from 0 to 1
      v_x, //x remapped from 0 to 255
      v_y, //y remapped from 0 to 255
      r, //0 to 255
      g, //0 to 255
      b, //0 to 255
      a, //0 to 255
      {
        ...uniform,
        width: c.width,
        height: c.height
      },
      r/255, //r from 0 to 1
      g/255, //g from 0 to 1
      b/255, //b from 0 to 1
      a/255, //a from 0 to 1
    );

    imgData.data[i+0] = r;
    imgData.data[i+1] = g;
    imgData.data[i+2] = b;
    imgData.data[i+3] = a;
    pixelIdx += 1;
  }
  ctx.putImageData(imgData, 0, 0);
}

var c = document.getElementById("myCanvas");
var img = document.getElementById("scream");

var c2 = document.querySelector('.canvas-chocolate');
var img2 = document.querySelector('.lindt-jpg');
var sel = document.querySelector('.dd-transformer');

var sliderWrap = document.querySelector('.slider-wrap');

var fileInput = document.querySelector('.file-input');

var procrastinator = false;

var uniform = {
  sliders: [],
  sliderLabels: []
};

transformers.forEach(function(tra){
  var opt = document.createElement('option');
  opt.value = tra.name;
  opt.innerText = tra.name;
  sel.appendChild(opt)
});

let selectedFN = transformers[0].fn

function getFN() {
  if (sel.selectedIndex == 0) { return false; }
  let tra = transformers[sel.selectedIndex - 1]; //nothing is in the 0 index
  return tra.fn;
}

sel.addEventListener('change',function(){
  //console.log('selInd',sel.selectedIndex);
  selectedFN = getFN();
  process(c,img,selectedFN) 
  process(c2,img2,selectedFN);
});

function fileOnload(e) {
  img2.src = e.target.result;
}

setTimeout(function(){
  //sometimtes this was causing process to run before the js modules have 
  //finished loading... so the setTimeout is an ugly temporary fix
  img2.addEventListener('load',function() {
    console.log('LOAD!!!');
    process(c2,img2,selectedFN);
  });



},2000);

fileInput.addEventListener('change',function(e){
  console.log(e.target.files);
  var file = e.target.files[0];
  var reader = new FileReader();
  reader.onload = fileOnload;
  reader.readAsDataURL(file);
});


/*

*/


[0,1,2,3,4,5,6,7,8,9].forEach(function(n){
  let sl = document.createElement('input');
  sl.step = 0.01;
  sl.min = 0;
  sl.max = 1;
  sl.value = 0;
  let label = document.createElement('label');
  label.innerText = '0 to 1'
  sl.type = 'range';
  sliderWrap.appendChild(sl);
  sliderWrap.appendChild(label);
  sl.addEventListener('change',function(e){
    //console.log(e.target.value,sl.value)
    clearTimeout(procrastinator);
    procrastinator = setTimeout(function() {
      process(c,img,selectedFN) 
      process(c2,img2,selectedFN);
    },100);
  });
  uniform.sliders.push(sl);
  uniform.sliderLabels.push(label);
});

</script>

</body>
</html>

